\newcommand{\barb}{\overline{b}}

\newcommand{\ComputeBern}{\texttt{ComputeBernsteinCoeffIntervals}}
\newcommand{\FindOverlaps}{\texttt{FindOverlapsWithGrid}}
\newcommand{\ComputeGridRep}{\texttt{ComputeGridGeneratorRep}}



\chapter{Applications to Real-time Reachability}
%
In this chapter, we briefly present some experimental results on an application of the Bernstein expansion on the realm of real-time reachability. First, we outline a few motivating factors as well as our proposed reachability algorithm. Second, we expound on some observations and negative experimental results as well as some early obstacles in the efficacy of our proposed algorithm.
%
\section{Motivation and Algorithm}
The context of these experiments is focused towards the perspectives of real-time reachability. Roughly speaking, the objective of an effective real-time reachability algorithm can be described as covering two criteria:
%
\begin{enumerate}
  \item The computed reachable set must be within some $\epsilon$ distance of the exact reachable set. We can think of this as the constraint dictating that the computed reachable set lies within an $\epsilon$ bloat of the exact reachable set (i.e if $\Theta$ denotes the exact reachable set and $\overline{\Theta}$ its computed over-approximation, then
    $ \overline{\Theta} \subset B_\epsilon(\Theta)$
    where
    $B_\epsilon(\Theta) = \bigcup_{x \in \Theta} B_{\epsilon}(x)$.)
  \item The running time to compute the over-approximation $\overline{\Theta}$ must be strictly upper-bounded by some ``reasonable" time period. Here, by reasonable, we generally speak of a time constraint imposed on real-time systems where predictable running is required for proper functionality.
\end{enumerate}

Recall from Sections \ref{sec:bernstein} and \ref{sec:static} that computing the Bernstein coefficients and taking their maximum and minimum coefficients is tantamount to bounding the solutions to non-linear optimization problems of the form presented in Equation \ref{eq:maxalpha}. As the degrees of the polynomial objective functions described by Equation \ref{eq:maxalpha} and dimensions of the system grow, the number of Bernstein coefficients also grows in exponential order. This is evident from the Bernstein coefficient formula defined in Equation \ref{eq:bernstein_coeff}.

To mitigate this explosive growth in coefficients, we can pose the following question: Is there a method for ascertaining a small subset of the basis monomials such that the correct maximum and minimum coefficients can be computed from this subset rather the entire set of Bernstein basis monomials?
%
Towards this end, we propose the following algorithm outlined in Algorithm \ref{alg:bern_prune} and elaborate on individual subroutines. In the context of these experiments, we assume the dynamics $f$ are polynomial. This is to ensure we have a Bernstein expansion of the composed dynamics $f \circ T_p$.

\input{bern_prune_alg}

\newcommand\litem[1]{\item{\bfseries #1 \\}}

\begin{enumerate}
\litem{Parition Domain into Grid Cells:} We first partition the domain into grid cells of equal dimension. Naturally the entire domain is infinite, so we must restrict the domain into bounded box of sufficiently large dimensions. This box must bound the reachable set computed for a finite number of steps forward. These grid cells will act as constraints to feed into our generator representation.

\litem{Initialize Generator Representation:} For each of the cells computed in the previous step, we set the anchor vertex and generator vector components to their corresponding grid cell dimension. In other words, we constrain the parallelotope to be contained within the cell through the generator representation. Formally speaking, suppose we have a grid cell $G$ in $n$-dimensional real vector space $\reals^n$ of the form $G = [l_1,u_1] \times [l_2, u_2] \times \cdots [l_n \times u_n]$. To constrain our parallelotope $P = \langle a, g_1, \cdots, g_n\rangle$ to be contained within $g$, it suffices to set the component variables such that $a, g_1, \cdots, g_n \in G$. For example, to set $a \in G$, the constraints should be initialized as below:
\begin{align}
\label{eq:gen_var_interval}
  a_1 \gets [l_1,u_1] & & a_2 \gets [l_2, u_2] & & \cdots & & a_n \gets [l_n,u_n]
\end{align}
%
%\begin{align*}
%  a_1 & \in [l_1,u_1] & a_1 & \in [l_2, u_2] & \cdots & & a_n \in [l_n,u_n] \\
%  g_{11} & \in [l_1,u_1] & g_{12} & \in [l_2, u_2] & \cdots&   & g_{1n} \in [l_n,u_n] \\
%  & \vdots & & \vdots &
%\end{align*}
%
In Algorithm \ref{alg:bern_prune}, the procedure responsible returning this assignment is $\ComputeGridRep$.

\litem{Perform the Functional Composition:} As stated in Equation \ref{eq:maxalpha}, the non-linear optimization predicate should be $\Lambda_i\cdot f$ for fixed template direction $\Lambda_i$. Under the assignments of the variables according to Equation \ref{eq:gen_var_interval} and interval arithmetic, we have the polynomial $\Lambda_i\cdot(f \circ T_p)$ where the coefficients are \emph{intervals} rather than real values.

\litem{Compute Bernstein Coefficient Intervals:} Now with our computed polynomial with interval coefficients, we can compute the Bernstein coefficient intervals using the formula displayed in Equation \ref{eq:bernstein_coeff}. By our initialization scheme above, this computation will yield intervals such that the Bernstein coefficients computed from any parallelotope contained in grid cell $P \subseteq G$ should lie within their respective coefficient intervals. Let $\{\barb_{\boldi}\}_{\boldi \in I_{G,\Lambda_i}}$ be the set of computed coefficient intervals where $I_{G,\Lambda_i}$ is an index of degrees which depend on the grid cell $G$ and template direction $\Lambda_i$. For the sake of clarity, we shall just denote this index set as $I$.

\litem{Find the Maximum/Minimum Interval:} Using $\{\barb_{\boldi}\}$, we find the maximum and minimum interval by simply finding the interval which has the largest upper-bound and the interval which has the smallest lower-bound. If $\barb_{\boldi} = [l_\boldi, u_\boldi]$, then
%
\begin{align}
  \mathfrak{I}_{G,\Lambda_i, \max} & = \argmax_{\boldi \in I} u_\boldi \\
  \mathfrak{I}_{G,\Lambda_i, \min} & = \argmin_{\boldi \in I} u_\boldi
\end{align}
%
Note that $\mathfrak{I}_{\max}, \mathfrak{I}_{\min}$ are the degrees of the Bernstein basis monomials whose intervals dominate the others. Additionally, we add all the intervals which overlap with the maximum and minimum intervals:
%
\begin{align}
  \begin{split}
      m_{G,\Lambda_i,\max} & = \{\boldi \in I ~|~ \barb_{\boldi} \cap \barb_{\mathfrak{I}_{\max}} \neq \emptyset \}\\
      m_{G,\Lambda_i,\min} & = \{\boldi \in I ~|~ \barb_{\boldi} \cap \barb_{\mathfrak{I}_{\min}} \neq \emptyset \}
  \end{split}
\end{align}

\litem{Store into Lookup Table:} The maximum and minimum intervals and their associated degrees are stored into a lookup table indiced by each grid cell and template direction $\Lambda_i$ in $\Lambda$.
\end{enumerate}

The required modifications to the reachability algorithm now turn out to be simple. Instead of computing all of the Bernstein coefficients, the algorithm first determines the grid cells with non-empty overlap with the parallelotope in question ($\FindOverlaps$). It then queries the monomials stored for each overlapping grid cell $G$: $ m_{G,\Lambda_i\max}, m_{G,\Lambda_i \min}$ in respect to the template direction $\Lambda_i$. This retrival is executed on lines 6,7 of Algorithm \ref{alg:bern_prune}. The rest of the reachability algorithm follows exactly as the logic of Algorithm \ref{alg:old}.

\section{Experimental Results}
We move onwards to the experimental results and observations. Our experiments were limited to the Vanderpol Model (Appendix Section \ref{sec:vdp}) and the SIR model (Example \ref{ex:sir}). A few parameters are required to be stated for posterity:

\begin{itemize}
  \item For both models, we attempted to run the modified reachability algorithm for seven steps.
  \item For both models, we partition the domain and fix the initial set for each model according to the below inputs:

  \begin{tabular}{|c|c|c|c|}
  \hline
  Model & Domain & Initial Set & \# of Grid Cells \\
  \hline
  Vanderpol & $[-3, 3] \times [-3, 3]$ & $[0.001, 0.005]\times [1.995, 2]$ & 1600 \\
  %\hline
  %SIR & $[0, 1]^3$ & $[0.799,0.8] \times [0.199,0.2] \times 0$ & 100 \\
  \hline
  \end{tabular}
\end{itemize}

During the course of experimentation, several observations hinting towards major obstacles hindering any trivial speed-up have been discovered for the two benchmark models. We list those obstacles below.

\subsection{Discrepancy of Degrees}
\label{sec:deg_disc}
This issue arises when we determine the maximum and minimum intervals and their associated monomials during the pre-computation step. We will demonstrate this phenomenon with the Vanderpol system.

Recall that the generator representation for a parallelotope $P$ would yield the linear transformation $T_P:[0,1] \rightarrow P$ which looks like $$ T_P(x,y) = q + g_0\cdot x + g_1\cdot y$$ for an anchor (base) vertex $q$ and two generator vectors $g_0,g_1$.
%
The composition with the generator representation would be tantamount to substituting the symbolic expressions as follows:
%
\begin{align} x & \leftarrow q_0 + g_{00}\cdot x + g_{01}\cdot y \\  y & \leftarrow q_1 + g_{01}\cdot x + g_{11}\cdot y\end{align}
%
The components of the composed mapping $f \circ T$ will individually look like:
%
\begin{align} (f \circ T)_0 & = q_1 + g_{01}\cdot x + g_{11}\cdot y \\ (f \circ T)_1 & = (1 - (q_0 + g_{00}\cdot x + g_{01}\cdot y)^2) * (q_1 + g_{01}\cdot x + g_{11}\cdot y) - (q_0 + g_{00}\cdot x + g_{01}\cdot y) \end{align}

If you inspect the polynomial $(f \circ T)_1$, the square times another linear factor of $x,y$ gives us a polynomial of degree $(3,3)$.
%
Suppose we calculate the non-linear optimization objective function as: $\Lambda_i \cdot (f \circ T_P)$ where we set $\Lambda_i = [0,1]^T$ (i.e the y-axis aligned vector), then the polynomial will be precisely be $(f \circ T)_1$, which has degree $(3,3)$.

However, the following occurs during the reachability algorithm: the actual polynomial computed for template direction $\Lambda_i =[0,1]^T$, that is the polynomial computed naturally during the parallelotope reachability algorithm, actually has lower degree than $(3,3)$.
%
Furthermore, the maximum and/or minimum degrees pre-computed actually of \emph{higher degree} than the degree of the actual polynomial computed during the procession of the algorithm. This would mean that the pre-computed degrees and their coefficient would never show up in the Bernstein expansion of the actual polynomial. To see this, recall Property \ref{prop:bern_basis}.

Consider the output presented in Figure \ref{fig:bern_prune_deg_output} computed with just the axis-aligned parallelotope over the VanderPol model with a grid parition of $40 \times 40$. We run the algorithm for one step and display the output during the optimization procedure for template direction $\Lambda_i = [0,1]^T$.
%-------------------------
\input{bern_prune_deg_output}
%-------------------------
In the first step above, the maximum degree is a lone monomial:
%
\begin{verbatim}
Returned set of Maximum Monom from Lookup Table:
[((3, 3), 2.18359741950000)]
\end{verbatim}
%
This means that the actual monomial with the maximum Bernstein coefficient:
\begin{verbatim}
Actual Max Monom Deg: (2, 0)
\end{verbatim}
%
was actually pruned out during the pre-computation phase.
%
What seems to happen quite frequently is the maximum or minimum intervals and their associated overlaps dominates the degree of the actual polynomial computed after composition during the reachability computation. To see this, note the anchor and generator vectors computed for the generator representation:
%
\begin{verbatim}
BASE VERTEX: [0.005, 2.0]
GENERATORS: [[-0.004, 0.0], [0.0, -0.0049999999999999]]
\end{verbatim}

The generators are axis-aligned, meaning that several degrees are annihilated during the composition $\Lambda_i\cdot (f\circ T_P)$. Hence, during our pre-computation step two, we consider a more general set of monomial degrees which may not reflect the relevant degree statistics found during the actual computation phase.

This poses the issue of having to know what the degrees supplied to the algorithm are before it even begins. In other words, we don't exactly know how the functional composition with the generator representation affects the degree of the resulting polynomial. If the degree is actually smaller than that of the monomial with the maximum/minimum coefficient interval (or its overlaps), then it will never show up during our reachability algorithm. This results in either a gross conservative error or an exception indicting that we pruned out too many monomials.
%
This error becomes further compounded if higher degree terms are wiped out by the 0 factors in the computed generator or if the wrapping error becomes worse.

One immediate thought could be to add templates which have non-axis-aligned template directions like $[-1,1]^T$. However, due to the ways higher degree terms can cancel each other out when simplifying after the functional composition, the degree of the polynomial after the composition could still be smaller than that of the maximum and minimum monomial and its overlaps.

To recapitulate, it appears that pre-computing the Bernstein coefficients and the subsequent analysis on their outputted intervals can overly skew the effect of ``non-relevant coefficients". These coefficients can only be pruned once the generator representation of the specific parallelotope is computed and the exact degree of the composed polynomial is determined.

\subsection{Contributions of Many Overlapping Cells}
Another obstacle stems from the observation that parallelotopes which have great overlap with many grid cells yield the full list of Bernstein coefficients. Hence, there is no speed-up gained in these cases. Consider the output displayed in Figure \ref{fig:bern_prune_wrapping_output} for step four.
%-------------------------
\input{bern_prune_wrapping_error}
%-------------------------
The main point to take here are the printed values of returned set of monomials from the lookup table:
%
\begin{verbatim}
Returned set of Maximum Monom from lookup_table:
 [((0, 1), 2.48598940176842),
 ((1, 2), 2.13075300161303),
 ((2, 1), 2.49645813555339),
 ...
 ((3, 3), 1.77817608667862)]
\end{verbatim}
%
From Step 4 onwards, the lookup table returns the full list of monomials of degree less than $(3,3)$ i.e all the relevant monomials during the pre-computation stage.
%
We tested this even for reachability computations lasting more than five steps. The full set of Bernstein coefficients are always returned after a certain step. For the Vanderpol model initialized with our parameters, this point would be around step $4$ or $5$.

As the wrapping error becomes worse, so does the utility of our lookup table. A guess is that as the conservativeness of our reachable becomes greater, it overlaps with more cells of the domain. This results in an cascading effect where the reachability algorithm is required to take into account more and more monomials as it progresses.

We speculate that the utility of our pruning method hinges on the careful control of the reachable set error. If the error becomes too great, we end of computing all of the coefficients, negating any benefits of a speed-up.
