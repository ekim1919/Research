\chapter{Preliminaries}
\label{chap:prelim}

We begin with some preliminaries pertaining to reachability and parallelotopes. The definition of Bernstein polynomials and their enclosure properties will be stated. Finally, an outline of the reachability algorithm given by \cite{dreossi2016parallelotope} for polynomial dynamical systems will be presented.

\section{Basic Definitions}
\label{sec:definitions}

As stated in the previous section, this thesis pertains to the reachability analysis of dynamical systems. Roughly speaking, a dynamical system describes the behavior of states governed by a set of differential equations. The states of the system evolve according to the flow of time and the vector field induced by the governing differential equations.

Towards introducing more terminology, the \emph{state} of a system, denoted as $x$, lies in a domain $D \subseteq \reals^n$ where the solutions to the differential equations are defined.
%
In the reachability analysis literature, there are several definitions for dynamical systems which appear depending on the authors' taste for formalisms. Here is a more rigorous definition appearing in \cite{dang1998reachability}:
\begin{definition}
\label{def:diff_dyna_sys}
A \emph{continuous dynamical system} is a tuple $\langle X, f \rangle$ where $X = \reals^n$ is finite-dimensional Euclidean space and $f$ is a continuous function on $X$. A point (state) of $x_0 \in X$ evolves according to a trajectory $\xi(t): \reals^+ \rightarrow X$ such that the following hold:
%
\begin{equation}
  \label{eq:diff_dyna_sys}
  \begin{split}
    \xi(0) & = x_0 \\
    \frac{d \xi(t)}{dt} & = f(\xi(t)) \quad \forall t \in \reals^+
  \end{split}
\end{equation}
\end{definition}
%
\noindent Note that, by a simple separation of variables argument and an initial value of $\xi(0) = x_0$, Equation \ref{eq:diff_dyna_sys} yields the following form for $\xi$:
\begin{equation}
\xi(t) = x_0 + \int_0^t f(\xi(\tau))\; d\tau
\end{equation}
%
\noindent However, many members of the research community choose to simply express the system as:
\begin{equation}
\label{eq:cont_dynas}
x' = f(x)
\end{equation}
for a continuous function $f:\reals^n \rightarrow \reals^n$. We restrict our attention to a discretized version of this definition for this thesis:
%
\begin{definition}
A \emph{discrete-time dynamical system} is denoted as
\begin{equation}
  x^{+} = f(x)
\label{eq:sys}
\end{equation}
where $f: \reals^{n} \rightarrow \reals^{n}$ is a function and $x^{+}$ denotes the evolved output state.
\end{definition}
%
 In other words, the function $f$ takes input a state of the system and outputs the next step of the system evolved according to the dynamics.
%
 The function $f$ generally represents a discretized version of some specified continuous dynamical system. Here, a discrete-time dynamical system is considered to be \emph{linear} if its dynamics can be expressed as

$$
x^{+} = Ax, \quad A \in \reals^{n \times n}
$$
%
Otherwise, we deem the system to be \emph{non-linear}.
%
Hence, in particular, a non-linear function $f$ cannot be expressed as some matrix $A \in \reals^{n \times n}$.

Examples of prominent non-linear dynamical systems include the Lotka-Volterra predator-prey model \cite{wangersky1978lotka}, the Fitz-Hugh Neuron model \cite{fitzhugh1961impulses}, and the recently introduced COVID19 disease model \cite{indiansuper2020supermodel}. Throughout this thesis, we discretize any continuous dynamics through the well-known Euler method. Thus, up to some error term of bounded degree, we can turn any non-linear system into the form given by Equation~\ref{eq:sys}.
%
\begin{example}
\label{ex:sir}
The SIR Epidemic model is a 3-dimensional dynamical system governed by the following continuous dynamics:
\begin{align} \label{eqn:sir}
    \begin{cases}
        s' &= \beta \cdot s i \\
        i' &= \beta \cdot s i - \gamma \cdot i \\
        r' &= \gamma \cdot i
    \end{cases}
\end{align}
where $s,i,r$ represent the fractions of a population of individuals designated as \textit{susceptible}, \textit{infected}, and \textit{recovered} respectively. There are two parameters, namely $\beta$ and $\gamma$, which influence the evolution of the system. $\beta$ is labeled as the \emph{contraction rate} and $1/\gamma$ is the \emph{mean infective period}.
%
Discretizing Equation~\ref{eqn:sir} according the Euler method yields the dynamics:

\begin{center}
\label{fig:discrete_sir}
  \begin{equation*}
      \begin{cases}
          s_{k+1} &= s_k - (\beta \cdot s_k i_k)\cdot\Delta \\
          i_{k+1} &= i_k + (\beta \cdot s_k i_k - \gamma \cdot i_k)\cdot\Delta \\
          r_{k+1} &= r_k + (\gamma\cdot i_k)\cdot\Delta
      \end{cases}
  \end{equation*}
  \captionof{figure}{Discretized Dynamics of SIR model}
\end{center}
 Here, $\Delta$ is the discretization step and the index $k \in \mathbb{N}$ simply represents the current step.
%For the benchmarks, we set $\beta = 0.34$, $\gamma=0.05$, and $\Delta=0.5$.
%
Note the non-linear terms $s_ki_k$, which preclude the expression of the dynamics as a linear transformation.
\end{example}

We can now give a discretized version of a trajectory as presented in Definition \ref{def:diff_dyna_sys}. The trajectory of a system that evolves according to Equation~\ref{eq:sys}, denoted as $\xi_{x_0}$, is a sequence $x_0, x_1, \ldots $ where $x_{i+1} = f(x_i)$.
%
The $k^{th}$ element in this sequence $x_k$ is denoted as $\xi_{x_0}(k)$.

\begin{definition}
Given an initial set $\Theta \subseteq \reals^n$, the \emph{reachable set at step $k$}, denoted as $\Theta_k$ is defined as
\begin{equation}
  \Theta_k = \{ \xi_x(k)\: | \: x \in \Theta\}
\label{eq:reachset}
\end{equation}
If we set the number of steps to be some $n \in \mathbb{N}$, we say the \emph{reachable set} is
\begin{equation}
  \Theta = \bigcup_{i=1}^n \Theta_i
\end{equation}
\end{definition}
%
\noindent Example \ref{ex:sir_kaa} gives the plot of the reachable set of the discretized SIR model presented in Figure~\ref{fig:discrete_sir}.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{Parallelotope-based Reachability}
\subsection{Parallelotopes}
\label{sec:parallelotope}
%
The heart of our reachability algorithm relies on geometric objects called \emph{parallelotopes}. In this section, we define parallelotopes and two representations for them.

\begin{definition}
\label{def:ptope}
A \emph{parallelotope} $P \subset \mathbb{R}^{n}$ is captured by the tuple $\langle \Lambda, c\rangle$ where $\Lambda \in \mathbb{R}^{2n \times n}$ is a matrix and $c \in \reals^{2n}$ is a column vector. We impose the condition that $\Lambda_{i+n} = -\Lambda_{i}$ for all $1 \leq i \leq n$ such that
%
\begin{equation}
\label{eq:halfspace}
x \in P \mbox{ if and only if } \Lambda x \leq c.
\end{equation}
%
\end{definition}
%
We deem $\Lambda$ as the \emph{template direction matrix} where $\Lambda_i$ denotes the $i^{th}$ row of $\Lambda$ called the \emph{$i^{th}$ template direction}. The column vector $c$ is called the \emph{offset vector} with $c(i)$ denoting the $i^{th}$ element of $c$.
%
If we unpack Equation~\ref{eq:halfspace}, we can re-express the inequalities as a conjunction of half-space constraints. If we define $c_{u} = [c(1), c(2), \cdots, c(n)]^T$ and $c_{l} = [c(n+1), c(n+2), \cdots, c(2n)]^T$, then Equation~\ref{eq:halfspace} tells us that, for $1 \leq i \leq n$:
%
\begin{align}
  & \Lambda_i x \leq c_u(i)  \label{eq:upper_ineq}\\
  -& \Lambda_i x \leq c_l(i) \label{eq:lower_ineq}
\end{align}
%
Additionally, the definition of the paralleotope above requires that for each of $n$ ``positive" directions, there must exist a corresponding ``negative" direction. This is encoded into the template matrix $\Lambda$ by the condition $\Lambda_{i+n} = -\Lambda_{i}$. However, by the observation made above, we only need to keep the positive directions and divide our offset vector into equal components with the top half encoding the offsets for the positive directions and the bottom half encoding the offsets for the negative directions. The bottom half must be multiplied by a negative sign to account for Inequality \ref{eq:lower_ineq}.
%
Combining these remarks yields the half-space representation of parallelotope $P$.
%
\begin{definition}
\label{def:halfspace_def}
The \emph{half-space representation} of parallelotope $P$ is tuple  $\langle \Lambda, c_l, c_u \rangle$ where $\Lambda \in \mathbb{R}^{n \times n}$ and $c_l, c_u \in \reals^n$
such that
\begin{align}
\label{eq:halfspaceconst}
P & =\{x ~|~ c_l \leq \Lambda x \leq c_u\}
\intertext{In a more explicit form:}
P & = \bigwedge_{i=1}^n \left[c_l(i) \leq \Lambda_i\cdot x \leq c_u(i) \right]\label{eq:halfspace_ineq}
\end{align}
\end{definition}
%
\noindent In particular, as a bounded intersection of $n$ pairs of parallel half-spaces, it is convex.
%
\begin{example}
\label{ex:simple_ptope}
Consider the 2D plane, namely $\reals^2$. We can construct a two simple examples of parallelotopes. First, if we define our parallelotope's template directions to be the rows of the matrix:
%
\begin{equation}
  \Lambda = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}
\end{equation}
%
We see that our template directions will be the vectors $[1,0]^T, [0,1]^T$. Suppose now we set our upper and lower offsets to be:
%
\begin{equation}
  c_l = [-1,-1]^T, \quad c_u = [1,1]^T
\end{equation}
Then by Definition \ref{def:halfspace_def}, the half-space representation is given by:
\begin{equation}
\begin{bmatrix}
  -1 \\ -1
\end{bmatrix} \leq \begin{bmatrix}
    1 & 0 \\ 0 & 1
  \end{bmatrix}\begin{bmatrix}
   x \\ y
  \end{bmatrix} \leq \begin{bmatrix}
    1 \\ 1
  \end{bmatrix}
\end{equation}
%
Accordingly, by Equation \ref{eq:halfspace_ineq}, the bounded region in space will be the intersection of the following linear constraints:
%
\begin{align}
  \begin{split}
  -1 \leq x \leq 1 \\
  -1 \leq y \leq 1
  \end{split}
\end{align}
This is exactly the scaled unitbox $[-1,1] \times [-1,1]$. In fact, we can easily generalize this to a general $n$-dimensional system by considering the template direction matrix $\Lambda = I_n$ where $I_n$ is the $n \times n$ identity matrix and two offset vectors $c_l, c_u$ of length $n$. This would yield the shifted $n$-dimensional unitbox:

\begin{figure}[t!]
  \centering
  \begin{tikzpicture}
    \draw[step=1cm,gray,very thin, style=help lines] (-3,-3) grid (3,3);
    \fill[blue!40!white, opacity=0.4] (-1,-1) rectangle (1,1);
    \draw[->, thick](0,1) -- (0,2) node[above] (0,2) {$[0,1]$};
    \draw[->, thick](1,0) -- (2,0) node[right] (2,0) {$[1,0]$};
    \draw[->, thick](-1,0) -- (-2,0) node[left] (-2,0) {$[-1,0]$};
    \draw[->, thick](0,-1) -- (0,-2) node[below] (0,-2) {$[0,-1]$};
    \draw[fill] (0,0) circle [radius=1pt];
    \node[above] (0,0) {$\mathcal{O}$};
    %\foreach \i in {-3,-2,...,3} \node[below] at (\i,0) {\scriptsize \i};
    %\foreach \i in {-3,-2,...,3} \node[right] at (0,\i) {\scriptsize \i};
  \end{tikzpicture}

  \caption{Plot of the axis-aligned parallelotope of Example \ref{ex:simple_ptope}.}
  \label{fig:axis_align_ptope}
\end{figure}

\begin{equation}
[c_l(1), \;c_u(1)] \times [c_l(2),\; c_u(2)] \times \cdots \times [c_l(n), \; c_u(n)]
\end{equation}
%
It is worth noting that axis-aligned box on the 2D plane above would give the representation:
\begin{align}
  \Lambda = \begin{bmatrix*}[r]
            1 & 0 \\
            0 & 1 \\
            -1 & 0 \\
            0 & -1 \\
            \end{bmatrix*} , \quad c = [2,2,-1,-1]^T
\end{align}
if we were to convert the half-space representation above into the form defined in Equation \ref{eq:halfspace}.
%
From here on out, we refer to parallelotopes defined by the $n$ axis-aligned directions as the \emph{axis-aligned} parallelotopes.
%
For a visual plot of above axis-aligned parallelotope, see Figure \ref{fig:axis_align_ptope}. The template directions are displayed as normal vectors to the pairs of parallel planes defining the parallelotope. $\mathcal{O}$ represents the origin $(0,0)$ and each side of a grid cell represents one unit of distance.



\end{example}

\begin{example}
  \label{ex:simple_diag_ptope}
  We can also consider the axis-aligned directions rotated $45^\circ$ counter-clockwise. This would yield the two diagonal directions $[1,1]^T, [-1,1]^T$. Suppose we set the upper and lower offsets to be $c_u = [1,1]^T$ and $c_l = [-1,-1]^T$ respectively. Then once again by Definition \ref{def:halfspace_def}:
  %
  \begin{equation}
  \begin{bmatrix}
    -1 \\ -1
  \end{bmatrix} \leq \begin{bmatrix*}[r]
      1 & 1 \\ -1 & 1
    \end{bmatrix*}\begin{bmatrix}
     x \\ y
    \end{bmatrix} \leq \begin{bmatrix}
      1 \\ 1
    \end{bmatrix}
  \end{equation}
  %
  The bounded region in $\reals^2$ will be the conjunction of the linear inequalities:
  %
  \begin{align}
    \begin{split}
    -1 \leq x + y \leq 1 \\
    -1 \leq y - x \leq 1
    \end{split}
  \end{align}
  %
  In general, we define \emph{diagonal directions} are defined to be vectors created by adding and subtracting distinct pairs of unit axis-aligned vectors from each other. As a matter of convenience however, we refer to \emph{diagonal parallelotopes} as those defined by a combination of axis-aligned \emph{and} diagonal directions. This definition will be useful when we consider parallelotopes defined by unconventional directions (i.e those template directions which are neither axis-aligned nor diagonal). To see a visual plot of the diagonal parallelotope, see Figure \ref{fig:diagonal_ptope}. Note the manner in which the template directions and their negative counterparts define parallel planes and the parallelotope's definition as the intersection of the postive and negative half-spaces of all pairs of parallel planes. Again, $\mathcal{O}$ represents the origin $(0,0)$ and each side of a grid cell represents one unit of distance.

  \begin{figure}[t!]
    \centering
    \begin{tikzpicture}
      \draw[step=1cm,gray,very thin, style=help lines] (-3,-3) grid (3,3);
      \draw[fill=blue!40!white, opacity=0.4] (1,0) -- (0,1) -- (-1,0) -- (0,-1) -- cycle;
      \draw[->, thick] (0.5,0.5) -- (1,1) node[above] {$[1,1]$};
      \draw[->, thick] (-0.5,-0.5) -- (-1,-1) node[below] {$[-1,-1]$};
      \draw[->, thick] (-0.5,0.5) -- (-1,1) node[above] {$[-1,1]$};
      \draw[->, thick] (0.5,-0.5) -- (1,-1) node[below] {$[1,-1]$};
      \draw[fill] (0,0) circle [radius=1pt];
      \node[above] {$\mathcal{O}$};
    \end{tikzpicture}
    \caption{Plot of the rotated parallelotope of Example \ref{ex:simple_diag_ptope}.}
    \label{fig:diagonal_ptope}
  \end{figure}
\end{example}


\noindent Alternatively, a parallelotope can also be represented in a generator representation.
%
\begin{definition}
\label{def:generator_def}
The \emph{generator representation} of a parallelotope $P$ is a tuple of vectors $\langle v, g_1, \ldots, g_n\rangle$ such that $v,g_1, \cdots g_n \in \reals^n$. The vector  $v$ is called the \emph{anchor} and the $g_i$ are called the \emph{generators}. The parallelotope is defined as the set:
$$
P := \{ x ~|~ \exists \alpha_1, \ldots, \alpha_n \in [0,1], \; x = v + \sum_{i=1}^n \alpha_i g_i \}
$$
\end{definition}
%
\begin{remark}
  \noindent This is esstentially a convex representation of the parallelotope, which shares many similarities to Zonotopes~\cite{girard2005reachability,althoff2010computing} and Star sets~\cite{duggirala2016parsimonious}.
  %
  %In particular, a parallelotope is a special case of a zonotope where the number of generators is exactly the dimension of the system $n$.
  %
  The most general definition of so-called \emph{template polyhedra} in $\reals^n$ is a tuple $\langle \Lambda, c \rangle$ such that $\Lambda \in \reals^{m \times n}$ for some $m \in \mathbb{N}$ and $c \in \reals^n$. The polyhedron is defined by the conjunction of linear
 inequalities:
%
 \begin{equation}
  \bigwedge_{i=1}^m \Lambda_i \cdot x \leq c_i
 \end{equation}
 %
It follows that parallelotopes are template polyhedra with $m=2n$ such that $\Lambda_{i+n} = -\Lambda_{i}$ for $1 \leq i \leq n$. Several verification tasks of hybrid automata with template polyhedra have been investigated in the reachability literature. See \cite{dang2011template, gronski2019template, sankaranarayanan2008symbolic} for more on related topics.
\end{remark}
%
There is a simple method to convert from the half-space representation of $P$ to its equivalent generator representation. The algorithm is sketched in Algorithm \ref{alg:rep_conversion}.
%
Line \ref{ln:find_anchor} ascertains the lower-most corner vertex of the input parallelotope. This vertex will be our anchor. The first loop starting at Line \ref{ln:first_loop} finds all of the vertices which are incident to the lower-most vertex through an boundary edge. There will be exactly $n$ of these incident vertices. The $i^{th}$ incident vertex can be computed by replacing the value stored in index $i$ of the lower offset vector $c_l$ with the value stored in the corresponding index $i$ of upper offset vector $c_u$.
%
\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \draw[step=1cm,gray,very thin, style=help lines] (-3,-3) grid (3,3);
    \draw[fill=blue!40!white, opacity=0.4] (1,0) -- (0,1) -- (-1,0) -- (0,-1) -- cycle;
    \draw[fill] (0,0) circle [radius=1pt];
    \node[above] {$\mathcal{O}$};

    \draw[fill] (0,-1) circle [radius=1.5pt];
    \node[below] at (0,-1) {$v$};

    \draw[->, very thick, draw=red] (0,-1) -- (-1,0) node[midway, left] {$g_1$};
    \draw[->, very thick, draw=red] (0,-1) -- (1,0) node[midway, right] {$g_2$};
  \end{tikzpicture}
  \caption{Plot of the generator representation for Example \ref{ex:simple_diag_ptope}. The vertex $v$ represents the anchor while the two vectors $g_1,g_2$ are the generator vectors.}
  \label{fig:axis_align_gen}
\end{figure}
%
Intuively, this process can be visualized as following the lower half-space boundary for each pair of parallel planes until we reach the intersection of the boundary with several other upper half-space boundaries.
%
See Figure \ref{fig:axis_align_gen} for a plot of this on the diagonal example considered in Example \ref{ex:simple_diag_ptope}.
%
Finally, the second loop starting at line eight calculates the generator vectors which will span the paralleltope through a convex combination $\bar{\alpha} \in [0,1]^n$. Note that the anchor is simply shifting the  generator vectors $g_i$ from the origin to the point required to properly span $P$.

There also exists a procedure to perform the reverse direction, namely to convert from the generator representation to the half-space representation. However, we will not require this procedure for this thesis. Refer to \cite{dang2014parameter} for a more detailed exposition of these conversions.

\begin{remark}
Notice that for a parallelotope $P$, the generator representation also defines an affine transformation that maps $[0,1]^{n}$ to $P$.
%
We refer to this affine transformation associated to $P$ as $T_P:[0,1]^n \rightarrow P$ when necessary.
\end{remark}

%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
\input{ptope_rep_convert_alg}
%------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\begin{example}
Let us return to the axis-aligned box considered in Example \ref{ex:simple_ptope}.
%
To obtain the anchor, we end up with the trivial solution $x = 1, y=1$ by adhering to Step 1. Hence, the anchor is set to $v = (1,1)$.
%
Subsequently, we solve for the two other vertices by following Step 2 to obtain $x=2, y= 1$ and $x=1,y=2$.
%
By Step 3, this would imply that the two generators are $g_1 = (2,1)-(1,1) = (1,0)$ and $g_2 = (1,2)-(1,1) = (0,1)$.
%
Now combine the anchor and generators to get the generator representation for this paralellotope:
%
\begin{equation}
 P = (1,1) + \alpha_1\cdot(1,0) + \alpha_2\cdot(0,1) \quad \alpha_1, \alpha_2 \in [0,1]
\end{equation}
%
This is exactly the unit box $[0,1]^2$ with its corner at the origin shifted to $(1,1)$.
\end{example}
%
\begin{example}
\label{ex:diag_ptope}
Parallelotope $P$ is given in half-plane representation as $0 \leq x-y \leq 1$, $0 \leq y \leq 1$.
%
This is a parallelotope with vertices at $(0,0)$, $(1,0)$, $(2,1)$, and $(1,1)$.
%
The template directions of the parallelotope $P$ are given by the directions $[1, -1]$ and $[0, 1]$.
%
The half-space representation in matrix form is given as follows:
%
\begin{equation}
  \begin{bmatrix} 0 \\ 0 \end{bmatrix} \leq \begin{bmatrix*}[r]  1 & -1 \\ 0 &  1 \end{bmatrix*}  \begin{bmatrix} x \\ y \end{bmatrix} \leq \begin{bmatrix} 1 \\ 1 \end{bmatrix}. \label{eq:ptopeexample}
\end{equation}
%
To compute the generator representation of $P$, we need to compute the \emph{anchor} and the \emph{generators}.
%
The anchor is obtained by solving the linear equations $x-y = 0, y = 0$.
%
Therefore, the anchor $a$ is the vertex at origin $(0,0)$
%
To compute the two generators of the parallelotope, we compute two vertices of the parallelotope.
%
Vertex $v_1$ is obtained by solving the linear equations $x - y = 1, y = 0$.
%
Therefore, vertex $v_1$ is the vertex $(1,0)$.
%
Similarly, vertex $v_2$ is obtained by solving the linear equations $x-y = 0, y = 1$.
%
Therefore, $v_2$ is the vertex $(1,1)$.
%
The generator $g_1$ is the vector $v_1 - a$, that is $(1,0)- (0,0) = (1,0)$
%
The generator $g_2$ is the vector $v_2 - a$, that is $(1,1) - (0,0) = (1,1)$.
%
Therefore, all the points in the paralellotope can be written as $(x,y) = (0,0) + \alpha_1 \cdot (1,0) + \alpha_2\cdot (1,1)$, $\alpha_1, \alpha_2 \in [0,1]$.
%
Figure \ref{fig:diag_ptope} portrays a visual plot of the derived generator representation.
\end{example}


\begin{figure}[h!]
  \centering
  \begin{tikzpicture}
    \draw[step=1cm,gray,very thin, style=help lines] (-3,-3) grid (3,3);
    \draw[fill=blue!40!white, opacity=0.4] (0,0) -- (1,0) -- (2,1) -- (1,1) -- cycle;
    \draw[fill] (0,0) circle [radius=1pt];
    \node[above] {$\mathcal{O}$};

    \draw[fill] (0,0) circle [radius=1.5pt];
    \node[below] at (0,0) {$v$};

    \draw[->, very thick, draw=red] (0,0) -- (1,0) node[midway, below] {$g_1$};
    \draw[->, very thick, draw=red] (0,0) -- (1,1) node[midway, right] {$g_2$};
  \end{tikzpicture}
  \caption{Plot of the generator representation for Example \ref{ex:diag_ptope}. The vertex $v$ represents the anchor while the two vectors $g_1,g_2$ are the generator vectors.}
  \label{fig:diag_ptope}
\end{figure}

%
The reachable set will be expressed an intersection of parallelotopes. These parallelotopes will be encoded into a parallelotope bundle.
%
\begin{definition}
A \emph{parallelotope bundle} $Q$ is a set of parallelotopes $\{P_0, \ldots, P_m\}$ such that
  $$ Q = \bigcap_{i=1}^{m}P_i $$.
\end{definition}

\begin{remark}
There is a slight abuse of notation above where we refer to the parallelotope bundle $Q$ as both the set of parallelotopes and the region in $\reals^n$ of the intersection of all the parallelotopes $P_i$. To specify the \emph{set of parallelotopes} which consists the bundle, we will write
$$
\mathcal{P}(Q) = \{P_0, \ldots, P_m\}
$$
\end{remark}

%
\noindent This parallelotope bundle will be the geometric data structure enclosing the region we compute to be the over-approximation of the exact reachable set. Observe that $Q$ can be expressed as the conjunction of all the linear constraints defining each parallelotope $P_i \in \ptopeset{Q}$.

%--------------------------------------------------------------------------------------------------------------------------------------------------------- --------
\newpage
\subsection{Bernstein Polynomials}
\label{sec:bernstein}
In this section, we define Bernstein polynomials and state some of their enclosure properties. A \emph{multi-index} ${\bf i}$ of length $n$ is defined as tuple of $n$ elements ${\bf i} = (i_1,\cdots, i_n)$ such that each $i_k \in \mathbb{N}$. Furthermore, we order the multi-indices as follows: if ${\bf i}$ and ${\bf j}$ are two multi-indices of length $n$, then
\[
  {\bf i} \leq {\bf j} \iff i_k \leq j_k, \quad 1 \leq  k \leq n
\]
Finally, we generalize the product of binomial coefficients over multi-indices as:
\[
  \binom{\boldi}{\boldj} := \prod_{k=1}^n \binom{i_k}{j_k}
\]
%
Given two multi-indices $\boldi$ and $\boldd$ of size $n$, where $\boldi \leq \boldd$, the Bernstein basis polynomial of degree $\boldd$ and index $\boldi$ is defined as:
\begin{equation}
\label{eq:bernstein_basis_poly}
\mathcal{B}_{(\boldi,\boldd)}(\boldx) = \beta_{i_1,d_1}(x_1) \beta_{i_2,d_2}(x_2)\ldots \beta_{i_n,d_n}(x_n).
\end{equation}
%
where for $i,d \in \mathbb{N}$ and $x \in \reals$:
%
\begin{equation}
\beta_{i,d}(x) = \binom{d}{i}x^{i}(1-x)^{d - i}
\end{equation}
%
Let $p: \reals^n \rightarrow \reals$ be a real polynomial of degree at most $\boldd$. We can express $p$ as a linear combination of monomials of degree at most $\boldd$:
\[
p(\boldx) = \sum_{\boldi \leq \boldd} a_\boldi \cdot \boldx^\boldi
\]
where $\boldx^\boldi$ represents the monomial $x_1^{i_1}x_2^{i_2}\cdots x_n^{i_n}$. One of the most important properties of Berstein polynomials is that the Bernstein basis polynomials of degree $\boldd$ span the vector space of real multivariate polynomials of degree at most $\boldd$:
%
In other words, given a polynomial $p(x_1,\ldots,x_n) = \sum_{j \in J} a_j {\bf x}_{j}$ where $J$ is a set of multi-indices iterating through the degrees found in $p$ with $a_j \in \mathbb{R}$, then $p(x_1,\ldots,x_n)$ can be converted into its counterpart under the Bernstein basis, $p(x_1,\ldots,x_n) = \sum_{j \in J} b_j \mathcal{B}_j $ where $b_j$ are the corresponding Bernstein coefficients.
\newpage
\begin{property}
\label{prop:bern_basis}
Every real polynomial $p$ of degree at most $\boldd$ can be represented as linear combination of Bernstein basis polynomials of degree $\boldd$:
%
\begin{equation}
  \label{eq:bernstein_coeff}
  p(\boldx) = \sum_{\boldi \leq \boldd} b_{\boldi} \cdot \mathcal{B}_{(\boldi,\boldd)}(\boldx)
\end{equation}
where $b_\boldi$ denotes the \emph{$\boldi^{th}$ Bernstein Coefficient}:

\begin{equation}
b_{\boldi} = \sum_{\boldj \leq \boldi} \frac{\binom{\boldi}{\boldj}}{\binom{\boldd}{\boldj}}\cdot a_{\boldj}
\end{equation}
\end{property}

The primary advantage of the Bernstein representation of a polynomial $p(x_1,...,x_n)$ is that an upper bound on the supremum and lower bound on the infimum of $p(x_1,...,x_n)$ in $[0,1]^{n}$ can be computed purely by observing the coefficients of the polynomial in the Bernstein basis. Specifically, the upper and lower bounds of $p(x_1,\ldots,x_n)$ over $[0,1]^n$ are bounded by the Bernstein coefficients. We state this as a property without proof.

\begin{property} (Enclosure Property)
  \label{prop:bern_enclosure}
  Let $p: \reals^n \rightarrow \reals$ be a real multivariate polynomial of degree $\boldd$, and let $p(\boldx) = \sum_{\boldi \leq \boldd} b_\boldi \cdot \mathcal{B}_{(\boldi,\boldd)}(\boldx)$ be the Bernstein expansion of $p$, then
  $$
  \min_{\boldi \leq \boldd} \{b_\boldi\} ~~\leq~~ \inf_{x \in [0,1]^n} p(x) ~~~~~\leq~~~~ \sup_{x \in [0,1]^{n}} p(x) ~~\leq~~ \max_{\boldi \leq \boldd} \{b_\boldi\}
  $$
\end{property}


As mentioned earlier, a parallelotope $P$ can also be represented as an affine transformation $T_{p}$ from $[0,1]^{n}$ to $P$.
%
Therefore, upper bounds on the suprenum of a polynomial function $p$ over $P$ is equivalent to upper bound of $p \circ T_{p}$ over $[0,1]^{n}$.
%
A similar argument follows for the lower bound on the infimum.
%
The crux of the reachability algorithm involves exploiting this property of Bernstein polynomials to approximate the solution of certain non-linear optimization problem involving polynomial predicates over the unitbox, $[0,1]^n$.
%
We will cover this algorithm in the upcoming section.
%
For a more rigorous exposition on Bernstein polynomials and Property~\ref{prop:bern_enclosure}, refer to \cite{garloff2003bernstein}.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------
\input{staticalg}
