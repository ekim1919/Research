\begin{figure}[t!]
\begin{algorithm}[H]
  \SetKwInput{KwInput}{Input}
  \SetKwInput{KwOutput}{Output}
  \SetKwFunction{CreatePCA}{CreatePCA}
  \SetKwFunction{CreateLin}{CreateLin}
  \SetKwFunction{TransformBund}{TransformBundle}
  \SetKwFunction{UpdateTemp}{UpdateTemplates}
  \SetKwFunction{GetSupp}{GetSupportPoints}
  \SetKwFunction{PropPoints}{PropagatePointsOneStep}
  \SetKwFunction{PCA}{PCA}
  \SetKwFunction{ApproxLinearTrans}{ApproxLinearTrans}
  \SetKwFunction{SetLifeSpan}{SetLifeSpan}
  \SetKwFunction{ExtractDirections}{ExtractDirections}
  \SetKwFunction{AddTemptoBund}{AddTemplateToBundle}
  \SetKwFunction{Maximize}{Maximize}
  \SetKwFunction{hstack}{hstack}
  \SetKwFunction{RemoveTemp}{RemoveTempFromBund}
  \SetKwProg{Fun}{Proc}{:}{}

\SetAlgoLined
\DontPrintSemicolon

\KwInput{Dynamics $f$, Initial Parallelotope $P_0$, Step Bound $S$, Lifespan Parameter $L$}
\KwOutput{Reachable Set Overapproximation $\overline\Theta_k$ at each step $k$}

$Q_0 = \{P_0 \}$ \;
$\Lambda^{accum} = I_n$ \;
% $\T_0 = \{ \{ P_0.\T_1, \ldots P_0.\T_n \} \}$ \;
$\Lambda^{Q_0} = \Lambda^{P_0}$ \tcp{Init Template Directions}

 \For{$k \in [1, 2, \ldots, S]$}{
    $P_{supp}$ = \GetSupp($Q_{k-1}$) (support points of $Q_{k-1}$) \;
    $P_{prop}$ = \PropPoints($P_{supp}$, $f$) (image of support points) \;

    $A$ =  \ApproxLinearTrans($P_{supp}$, $P_{prop}$) \; \label{ln:linearapprox}
    $\Lambda^{accum} = \Lambda^{accum} \cdot A^{-1}$ \;
    $\Lambda_k^\text{lin} = \Lambda^{accum}$ \\ \; \label{ln:linapp}
    $\Lambda_k^\text{pca} = \PCA(P_{prop}) $\; \label{ln:pca}

    $\Lambda_k = \hstack(\Lambda_k^\text{lin}, \Lambda_k^\text{pca})$ \;
    $\Lambda^{total} = \Lambda_k$ \;
    \For{$ i \in [1,2, \ldots, L]$}{ \tcp{If $L = 0$, then skip}
        $\Lambda^{total} = \hstack(\Lambda^{total}, \Lambda_{k-i})$
    } \;
    $Q_k$ = \TransformBund($f$, $Q_{k-1}, \Lambda_k$) \;
   $\overline\Theta_k \gets Q_k$ \;
 }
 \Return{$\overline\Theta_1 \ldots \overline\Theta_S$} \;
 %
 \;
   \Fun{\GetSupp{$Q$}}{
     $P_{supp} = \emptyset$ \;
      \For{$P \in \ptopeset{Q}$}{
        \For{$i \in [1, 2, \ldots, n]$}{
         $P_{supp} = P_{supp} \cup ~ \Maximize (Q, \Lambda_i^P) \cup ~ \Maximize (Q, -\Lambda_i^P)$
        }
     }

  \Return{$P_{supp}$}
  }
\end{algorithm}
\caption{The Automatic, Dynamic Reachability Algorithm}
 \label{alg:new}
\end{figure}
